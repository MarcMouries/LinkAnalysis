<!DOCTYPE html>
<html>

<head>
	<script type="text/javascript" src="trigo.js"></script>
	<script type="text/javascript" src="links_icons.js"></script>
	<script type="text/javascript" src="image_utils.js"></script>
	<script type="text/javascript" src="MCanvas.js"></script>
</head>

<style type="text/css">
	:root {
		--radius: 3px;
		--small: 0.5em;
		--medium: 1em;
		--large: 1.5em;
		--shadow: 0 1px 2px rgba(16, 10, 9, 0.15);
		--gray-400: #d3d0c9;
	}

	#chart_container {
		width: 100%;
		height: 100%;
		background: white;
	}

	#chart_container_OLD {
		position: fixed;
		width: 1200px;
		height: 1000px;
		top: 0;
		left: 0;
		right: 23em;
		bottom: 0;
	}

	body {
		margin: 0;
	}

	.wrapper {
		min-height: 100vh;
		_background: #ccc;
		display: flex;
		flex-direction: column;
	}

	.header,
	.footer {
		height: 50px;
		background: #666;
		color: #fff;
	}

	.content {
		display: flex;
		flex: 1;
		background: #999;
		color: #000;
	}

	.columns {
		display: flex;
		flex: 1;
	}



	.main {
		flex: 1;
		order: 2;
		background: #eee;
	}

	.sidebar-first {
		width: 20%;
		background: #ccc;
		order: 1;
	}

	.sidebar-second {
		width: 20%;
		order: 3;
		background: #ddd;
	}

	.box {
		display: block;
		background: #fff;
		border-radius: var(--radius);
		box-shadow: var(--shadow);
		padding: var(--small);
		transition: box-shadow var(--transition);
		font: 100%/1.5 Helvtica Neue, Helvetica, sans-serif;
		margin: 5px;
	}

	table {
		width: 100%;
		text-align: left;
		border-collapse: collapse;
		background: #fff;
		color: var(--gray-800);
	}

	table input[type=text] {
		padding: 0 var(--small);
	}

	tr {
		border-bottom: thin solid var(--gray-400);
	}

	tr:focus-within {
		background: highlight
	}

	th h3 {
		padding: 0 var(--small);
	}

	h3 {
		font-weight: 500;
		line-height: 1;
		font-size: 1em;
		margin-bottom: var(--radius);
	}

	.value-column input {
		font: 100%/1.4 monospace
	}



	.box header {
		font-size: 1.2em;
		margin: 0;
		font-weight: 400;
	}

	table input {
		border: 0;
	}

	canvas {
		width: 100%;
		min-height: 400px;
		border: solid 2px red;
	}
</style>

<body>
	<div class="wrapper">
		<header class="header">Header: Fixed height</header>
		<section class="content">
			<div class="columns">
				<main class="box main">
					<div id="chart_container"></div>
				</main>
				<aside class="box sidebar-first">Sidebar first: Fixed width</aside>
				<aside class="box sidebar-second">
					<header>Data</header>
					<div class="data-table">
						<table>
							<thead>
								<tr>
									<th class="name-column">
										<h3>Name</h3>
									</th>
									<th class="value-column">
										<h3>Value</h3>
									</th>
									<th></th>
								</tr>
							</thead>
							<tbody>
								<tr id="row-7xkan8q5">
									<td class="name-column"><input type="text" value="First Name"></td>
									<td class="value-column"><input type="text" value="Joe"></td>
								</tr>
								<tr id="row-7xkan8q5">
									<td class="name-column"><input type="text" value="Last Name"></td>
									<td class="value-column"><input type="text" value="Smith"></td>
								</tr>

							</tbody>
						</table>
					</div>
				</aside>
			</div>
		</section>
		<footer class="footer">Footer: Fixed height</footer>
	</div>
</body>

<script>
	window.onload = function () {

		function log(msg) {
			if (true) {
				console.log(msg);
			}
		}


		// =============================================================
		//                          Node
		// -------------------------------------------------------------
		// 
		// =============================================================
		function Node(id, data) {
			this.id = id;
			this.data = data;
			this.depth = -1;
			this.adjacentList = [];
		}

		Node.prototype.addAdjacent = function (node) {
			this.adjacentList.push(node);
		};

		Node.prototype.getAdjacents = function (node) {
			return this.adjacentList;
		};

		Node.prototype.isAdjacent = function (node) {
			return this.adjacentList.indexOf(node) > -1;
		};

		// =============================================================
		//                          Link
		// =============================================================
		function Link(source, target) {
			this.id = source.id + "-" + target.id;
			this.source = source;
			this.target = target;
		}

		// =============================================================
		//                          Graph
		// =============================================================
		function Graph() {
			this.graph = {};
			this.nodeList = [];
			this.linkList = [];
			this.adjacency = {};
		}

		/**
		 *
		 */
		Graph.prototype.addObject = function (object) {
			var node = new Node(object.id, object);
			//console.log("added node : " + node.id);
			//console.log(node);
			this.addNode(node);
			return node;
		};

		Graph.prototype.addNode = function (node) {
			if (!(node.id in this.graph)) {
				this.nodeList.push(node);
				this.graph[node.id] = node;
			}
			return node;
		};

		/**
		 * Check if the specified node is a target in the list of links
		 */
		Graph.prototype.isRoot = function (node) {
			//  console.log(" IS ROOT ?");
			//  console.log("node: " + node_id);
			var exist = false;
			this.linkList.forEach(function (link, index) {
				if (link.target.id === node.id) {
					exist = true;
					// console.log("link source: " + link.source.id);
					// console.log("link target: " + link.target.id);
				}
			});
			return (is_root = !exist);
		};

		Graph.prototype.addLink = function (sourceNode_id, targetNode_id) {
			var sourceNode = this.getNode(sourceNode_id);
			if (sourceNode == undefined) {
				throw new TypeError(
					"Trying to add a link to the non-existent node with id: " + sourceNode_id
				);
			}
			var targetNode = this.getNode(targetNode_id);
			if (targetNode == undefined) {
				throw new TypeError(
					"Trying to add a link to the non-existent node with id: " + targetNode_id
				);
			}

			var link = new Link(sourceNode, targetNode);
			var exists = false;

			this.linkList.forEach(function (item) {
				if (link.id === item.id) {
					exists = true;
					//console.log("link " + link.id + " exists? = " + exists);
				}
			});

			if (!exists) {
				this.linkList.push(link);
				sourceNode.addAdjacent(targetNode);
			}

			if (!(link.source.id in this.adjacency)) {
				this.adjacency[link.source.id] = {};
			}
			if (!(link.target.id in this.adjacency[link.source.id])) {
				this.adjacency[link.source.id][link.target.id] = [];
			}

			//console.log("link source: " + link.source.id);
			//console.log("link target: " + link.target.id);
			this.adjacency[link.source.id][link.target.id].push(link);
		};

		Graph.prototype.getNode = function (nodeID) {
			var node = this.graph[nodeID];
			return node;
		};

		Graph.prototype._getAdjacents = function (nodeID) {
			var node = this.graph[nodeID];
			return this.adjacency[node.id];
		};


		Graph.prototype.getNodes = function (node) {
			return this.nodeList;
		}
		Graph.prototype.getLinks = function () {
			return this.linkList;
		}

		function printNode(node) {
			var adjacentsRepresentation = "";
			if (node.getAdjacents() == 0) {
				adjacentsRepresentation = "∅";
			} else {
				adjacentsRepresentation = node
					.getAdjacents()
					.map(function (item) {
						return item.id;
					})
					.join(", ");
			}
			return node.id + " => " + adjacentsRepresentation;
		}
		Graph.prototype.toString = function () {
			return this.nodeList.map(printNode);
		};

		Graph.prototype.loadJSON = function () {
			console.error("Graph.prototype.loadJSON  NOT IMPLEMENTED");
		};

		//
		Graph.prototype.getNodesAtLevel = function (level) {
			return [];
		};

		Graph.prototype.visit_breadth_first = function (starting_node, callback) {
			var max = 0;

			if (starting_node && starting_node.getAdjacents().length > 0) {
				var depth = -1;
				var fifo = [];
				var nodes_at_level = [];

				fifo.push(starting_node);
				while (fifo.length > 0) {
					var node = fifo.shift();

					if (node.depth >= depth) {
						if (depth > -1) {
							callback(depth, nodes_at_level);
						}
						depth++;
						max = Math.max(max, nodes_at_level.length);
						nodes_at_level = [];
					}
					node.depth = depth;
					nodes_at_level.push(node);
					node.getAdjacents().forEach(function (item, index) {
						item.depth = depth;
						fifo.push(item);
						//  console.log("item #: " + item.id + " (level: " + level);
					});
				}
				callback(depth, nodes_at_level);
				return Math.max(max, nodes_at_level.length);
			}
			return 0;
		};

		// =============================================================
		//                          Graph Utils
		// =============================================================

		function visit_nodes_at_level(level, nodes_at_level) {
			maxDepth++;
			var to_string = nodes_at_level
				.map(function (item) {
					return item.id + " (" + item.depth + ")";
				})
				.join(", ");
			console.log("Level " + level + ": " + to_string);
		}

		function to_string_node_list(node_list) {
			var to_string = node_list
				.map(function (item) {
					return item.id + " (" + item.depth + ")";
				})
				.join(", ");

			return to_string;
		}




		function build_nodes_at_level() {
			var nodes_by_level = [];

			graph.visit_breadth_first(root_node, function (
				level,
				nodes_at_current_level
			) {
				// console.log("Level " + level + ": " + to_string);
				nodes_by_level[level] = nodes_at_current_level;
			});
			return nodes_by_level;
		}




		// =============================================================
		//                          MChartView
		// =============================================================
		function MChartView({ mcanvas }) {
			this.mcanvas = mcanvas;
			this.ctx = mcanvas.getContext();
			//log(this.mcanvas);
			//log("MChartView.getWidth = " + this.getWidth());
			//log("MChartView.getHeight = " + this.getHeight());
			this.background_color = "#FFFFFF";//"#F5F5F5";

			this.color_ring_isActivated = "#3b6978";
			this.color_ring_isBelowMouse = "#84a9ac";

		}
		MChartView.prototype.getContext = function () {
			return this.ctx;
		};
		MChartView.prototype.getHeight = function () {
			return this.mcanvas.getHeight();
		};
		MChartView.prototype.getWidth = function () {
			return this.mcanvas.getWidth();
		};
		MChartView.prototype.addEventListener = function (type, listener) {
			this.mcanvas.addEventListener(type, listener);
		};
		MChartView.prototype.clear = function () {
			this.ctx.clearRect(0, 0, this.getWidth(), this.getHeight());
		};
		MChartView.prototype.drawBorder = function () {
			//log("MChartView.drawBorder");
			//this.mcanvas.drawBorder(this.background_color);
		}
		MChartView.prototype.renderLink = function (link) {
			//log("renderLink " + link.id);
			var strokeStyle = "grey";
			var lineWidth = "1";
			this.mcanvas.drawLine(link.source.x, link.source.y, link.target.x, link.target.y, strokeStyle, lineWidth);
		}
		MChartView.prototype.renderNode = function (node) {

			//log(`MChartView.renderNode: ${node.data.name}: ${node.x},${node.y} `);

			if (node.type == "person") {
				//console.log("it's  a person");
			}
			else if (node.type == "case") {
				//console.log("it's  a person");
			}

			var font = "12px Arial"
			var text_color = "#333";
			this.mcanvas.drawPoint(node.x, node.y, node.radius, "A. " + node.data.name);
			//this.mcanvas.drawTextBG("B. " + node.data.name, node.x, node.y, font, 0, this.background_color);

			var padding_node_title = 0;
			var maxLineWidth = 1.5 * (2 * node.radius);
			// CENTER TEXT
			var y = node.y + padding_node_title;
			//this.mcanvas.drawText(node.x, y, "C. " + node.data.name, font, text_color, maxLineWidth, ",");

			if (node.isClicked) {
				this.mcanvas.drawRing(node.x, node.y, node.radius + 5, this.color_ring_isActivated, "", 5);

			}
			else if (node.isBelowMouse) {
				this.mcanvas.drawRing(node.x, node.y, node.radius + 5, this.color_ring_isBelowMouse, "", 5);

			}
		}



		// =============================================================
		//                          MRadialLayout
		// =============================================================
		function MRadialLayout() {
		}

		MRadialLayout.Calculate_Positions = function (graph, starting_vertex, center) {
			//log(`MRadialLayout.Calculate_Positions: ${starting_vertex.data.name}`);

			var RADIUS_LEVEL = 150;

			if (!graph || graph.getNodes().length == 0) {
				console.error("MRadialLayout: can't run on an empty graph.");
				return;
			}
			if (starting_vertex == 'undefined') {
				console.error("MRadialLayout: can't run without a starting vertex. Which node should be the center?");
				return;
			}
			if (center == 'undefined') {
				console.error("MRadialLayout: can't run without a center set.");
				return;
			}

			if (graph.isRoot(starting_vertex)) {
				starting_vertex.x = center.x;
				starting_vertex.y = center.y;
				starting_vertex.angle = 0;
				starting_vertex.angleRange = 2 * Math.PI;
				//log(`*** MRadialLayout ROOT id=${starting_vertex.id}, 
				//			x=${starting_vertex.x}, y=${starting_vertex.y}, depth=${starting_vertex.depth},
				//            angle=${to_degrees(starting_vertex.angle)}°- angleRange=${to_degrees(starting_vertex.angleRange)}°`);
			}

			var nodes = graph.getNodes();
			var children_count = starting_vertex.getAdjacents().length;
			//console.log(`*** MRadialLayout vertex id=${starting_vertex.id}: # children=${children_count}`);

			for (var i = 0; i < children_count; i++) {
				var child = starting_vertex.getAdjacents()[i];
				var slice_angle = starting_vertex.angleRange / children_count;

				// to center the vertices 
				var centerAdjust = 0;
				if (child.depth > 1) {
					centerAdjust = (-starting_vertex.angleRange + starting_vertex.angleRange / children_count) / 2;
				}
				child.angle = starting_vertex.angle + (slice_angle * i) + centerAdjust;
				child.angleRange = slice_angle;
				//console.log("slice_angle = " + slice_angle);
				//console.log("child _angle = " + slice_angle * c);
				var cx = RADIUS_LEVEL; //* child.depth;
				var cy = 0;

				//var location = getPointOnArc(cx, cy, RADIUS, child.angle);
				var rotation = rotate(cx, cy, child.angle);
				//log(`*** MRadialLayout rotation =${rotation.x},${rotation.y}`);
				child.x = starting_vertex.x + rotation.x;
				child.y = starting_vertex.y + rotation.y;

				//log(`*** MRadialLayout child id=${child.id}, x=${child.x}, y=${child.y},depth=${child.depth},
				//           angle=${to_degrees(child.angle)}°- angleRange=${to_degrees(child.angleRange)}°`);

				//  RECURSIVE CALL on children
				MRadialLayout.Calculate_Positions(graph, child, center);
			}
		};


		// =============================================================
		//                          LinkAnalysis
		// =============================================================
		function LinkAnalysis(chart_container) {

			var NODE_GROUP_CLASS = "nodeXXX";
			var image_width = 35;
			var image_height = image_width;
			var node_width = image_width;
			var node_height = image_width;


			this.NODE_RADIUS = 20;
			var icon_width = 40;
			var icon_heigth = 40;

			// COLORS ???

			this.graph = new Graph();
			this.nodes_at_level = [];

			var linkAnalysis = this;

			// the imgs[] array now holds fully loaded images
			this.mcanvas = new MCanvas({ container: chart_container });
			this.view = new MChartView({ mcanvas: this.mcanvas });


			//this.current_node = null;
			this.context = this.view.getContext();
			//			this.addEventListeners();
			/////////////
			console.log("getComputedStyle");
			console.log("----------------");

			const style = document.defaultView.getComputedStyle(this.mcanvas.canvas, null);
			this.stylePaddingLeft = parseInt(style['paddingLeft'], 10);
			this.stylePaddingTop = parseInt(style['paddingTop'], 10);
			this.styleBorderLeft = parseInt(style['borderLeftWidth'], 10);
			this.styleBorderTop = parseInt(style['borderTopWidth'], 10);
			// Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
			// They will mess up mouse coordinates and this fixes that
			var html = document.body.parentNode;
			this.htmlTop = html.offsetTop;
			this.htmlLeft = html.offsetLeft;
			console.log(" this.htmlTop: " + this.htmlTop);
			console.log(" this.htmlTop: " + this.htmlTop);
			//////////////


			function handleMouseDown(event, callback) {
				console.log("handleMouse_Down");
				//event.preventDefault();

				var mouse = linkAnalysis.getMouse(event);
				console.log("handleMouse_Down mouse @ " + mouse.x + "," + mouse.y);

				var nodes = linkAnalysis.graph.getNodes();
				for (var i = 0; i < nodes.length; i++) {
					var node = nodes[i];
					if (pointInCircle(mouse.x, mouse.y, node)) {
						//	if (pointInCircle(event.clientX, event.clientY, node)) {
						console.log("handleMouse_Down node '" + node.data.name + "' isClicked");
						node.isClicked = true;
						linkAnalysis.selection = node;
						linkAnalysis.dragoffx = mouse.x - node.x;
						linkAnalysis.dragoffy = mouse.y - node.y;
						linkAnalysis.dragging = true;
						linkAnalysis.valid = false;

						// @TODO: Add Callback to listerer(node);
						callback(node);
						return;
					}
					else {
						node.isClicked = false;
					}
				}
				linkAnalysis.render();
			}

			function handleMouseMove(event) {
				console.log("in handleMouse_Move");
				//event.stopPropagation();
				var mouse = linkAnalysis.getMouse(event);

				// Highlight Node when mouse over
				var nodes = linkAnalysis.graph.getNodes();
				for (var i = 0; i < nodes.length; i++) {
					var node = nodes[i];
					if (pointInCircle(mouse.x, mouse.y, node)) {
						//if (pointInCircle(event.clientX, event.clientY, node)) {
						console.log("handleMouse_Move node '" + node.data.name + "' isBelowMouse");

						node.isBelowMouse = true;
					}
					else {
						node.isBelowMouse = false;
					}
				}

				if (linkAnalysis.dragging) {
					// We don't want to drag the object by its top-left corner,
					// we want to drag from where we clicked.
					// Thats why we saved the offset and use it here
					linkAnalysis.selection.x = mouse.x - linkAnalysis.dragoffx;
					linkAnalysis.selection.y = mouse.y - linkAnalysis.dragoffy;
					linkAnalysis.valid = false; // Something's dragging so we must redraw
				}
				linkAnalysis.render();
			}

			function handleMouseUp(event) {
				//console.log(" handleMouse UP");
				linkAnalysis.dragging = false;

				/*
				if (controller.current_node != null) {
					controller.current_node.isClicked = true;
					//controller.current_node = null;
				}
				else {
					controller.current_node.isClicked = false;
					controller.current_node = null;
				}
*/
				if (linkAnalysis.current_node) {
					console.log("linkAnalysis.current_node " + linkAnalysis.current_node.data.name + " isClicked");
					linkAnalysis.nodeClickHandler(controller.current_node);
				}
				linkAnalysis.render();
			}

			this.view.addEventListener("mouseup", handleMouseUp, false);
			this.view.addEventListener("mousemove", handleMouseMove, false);
			this.view.addEventListener("mousedown", function (event) {
				console.log("nodeClickHandler=" + linkAnalysis.nodeClickHandler);
				handleMouseDown(event, linkAnalysis.nodeClickHandler);
			});
		}

		LinkAnalysis.prototype = {

			addObject: function (object) {
				//console.log("LinkAnalysis addNode: " + object);

				var node = this.graph.addObject(object);
				node.radius = this.NODE_RADIUS;

				//linkAnalysis.updateGraph();
			},


			addLink: function (sourceNode_id, targetNode_id) {
				//console.log("LinkAnalysis addLink: " + sourceNode_id + " / " + targetNode_id);
				this.graph.addLink(sourceNode_id, targetNode_id);
				//linkAnalysis.updateGraph();
			},

			render: function () {
				//console.log("LinkAnalysis.render");
				//console.log("==> LinkAnalysis this.graph = ");
				//console.log(this.graph);


				// RADIAL
				var starting_vertex = this.graph.getNode("CEO Smith");
				//console.log("==> LinkAnalysis starting_vertex = " + starting_vertex.id);


				if (this.nodes_at_level.length == 0) {
					// calculate the depth of each node from the starting vertex
					this.graph.visit_breadth_first(starting_vertex, function (level, nodes_at_current_level) {
						// console.log("Level " + level + ": " + to_string);
						linkAnalysis.nodes_at_level[level] = nodes_at_current_level;
					});
					console.log("nodes_at_level");
					console.log(this.nodes_at_level);


					this.center = { x: this.view.getWidth() / 2, y: this.view.getHeight() / 2 };
					MRadialLayout.Calculate_Positions(this.graph, starting_vertex, this.center);
				}

				this.view.clear();
				this.view.drawBorder();

				// LINKS 
				var links = this.graph.getLinks();
				for (var i = 0; i < links.length; i++) {
					var link = links[i];
					this.view.renderLink(link);
				}

				// NODES
				var nodes = this.graph.getNodes();
				for (var i = 0; i < nodes.length; i++) {
					var node = nodes[i];
					//log("LinkAnalysis render node: " + node.id);
					this.view.renderNode(node);
				}
			},

			setNodeClickHandler: function (nodeClickHandler) {
				this.nodeClickHandler = nodeClickHandler;
				console.log("nodeClickHandler=" + this.nodeClickHandler);
			},

			// Creates an object with x and y defined,
			// set to the mouse position relative to the state's canvas
			// If you wanna be super-correct this can be tricky,
			// we have to worry about padding and borders

			getMouse: function (e) {
				var element = this.mcanvas.canvas, offsetX = 0, offsetY = 0, mx, my;

				// Compute the total offset
				if (element.offsetParent !== undefined) {
					do {
						offsetX += element.offsetLeft;
						offsetY += element.offsetTop;
					} while (element = element.offsetParent);
				}

				// Add padding and border style widths to offset
				// Also add the offsets in case there's a position:fixed bar
				offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
				offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

				mx = e.pageX - offsetX;
				my = e.pageY - offsetY;

				//mx = e.pageX ;
				//my = e.pageY ;

				// We return a simple javascript object (a hash) with x and y defined
				return { x: mx, y: my };
			},

			updateGraph: function () {
				this.render();
			}
		}


		LinkAnalysis.prototype.setIconByNodeType = function (IconByNodeType) {
			this.IconByNodeType = IconByNodeType;
		}

		function Circle(x, y, radius, fill, stroke) {
			this.startingAngle = 0;
			this.endAngle = 2 * Math.PI;
			this.x = x;
			this.y = y;
			this.radius = radius;
			this.fill = fill;
			this.stroke = stroke;
			this.isClicked = false;
			this.isBelowMouse = false;
			this.offset = { x: 0, y: 0 };


			Circle.prototype.drawImage__ = function (context, image) {
				var icon_x = this.x - icon_width / 2; // to fit into circle
				var icon_y = this.y - icon_heigth / 2; // to fit into circle
				context.drawImage(image, icon_x, icon_y, icon_width, icon_heigth);
			}

			this.draw = function (context) {
				//console.log("Circle.draw()");
				context.beginPath();
				context.fillStyle = this.fill;

				//console.log("x=" + this.x + ", y=" + this.y + " r=" + this.radius);

				context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
				context.fill();

				// TODO
				// IconByNodeType does not exist in the class Circle
				var node_type = "case";

				var icon_element = this.IconByNodeType[node_type];
				if (icon_element) {
					var image = icon_element.image;
					if (!image) {
						console.log("=====");
						console.log(ICON_LIST[node_type]);
						console.log("=====");
					}
					this.drawImage(context, image);
				}
				else {
					console.log("IconByNodeType " + this.IconByNodeType + " does not exist in the class Circle");

				}

				//console.log("isBelowMouse: " + this.isBelowMouse);
				if (this.isClicked) {
					//this.drawRing(context, color_ring_isActivated);
					this.drawRing(context, "blue");
				}
				else if (this.isBelowMouse) {
					//this.drawRing(context, color_ring_isBelowMouse);
					this.drawRing(context, "green");
				}
			}
		}
		// =============================================================
		//                          MAIN FUNCTIONS
		// =============================================================
		var IconByNodeType = {
			"case": {
				"url": icon_case_base64
			},
			"arrest": {
				"url": icon_arrest_base64
			}
		};


		var chart_container = document.getElementById("chart_container");
		var linkAnalysis = new LinkAnalysis(chart_container);
		var options = {};
		//	linkAnalysis.draw(graph_data, options);

		var ceo_smith = { id: "CEO Smith", name: "CEO Smith", type: "person" };
		var vp_north = { id: "VP North", name: "VP North", type: "person" };
		var vp_east = { id: "VP East", name: "VP East", type: "person" };
		var vp_south = { id: "VP South", name: "VP South", type: "person" };
		var vp_west = { id: "VP West", name: "VP West", type: "person" };

		linkAnalysis.addObject(ceo_smith);

		linkAnalysis.addObject(vp_east);
		linkAnalysis.addLink("CEO Smith", "VP East");

		linkAnalysis.addObject(vp_south);
		linkAnalysis.addLink("CEO Smith", "VP South");

		linkAnalysis.addObject(vp_west);
		linkAnalysis.addLink("CEO Smith", "VP West");

		linkAnalysis.addObject(vp_north);
		linkAnalysis.addLink("CEO Smith", "VP North");

		add_objects_and_links(linkAnalysis, 3, "East", "VP East");
		add_objects_and_links(linkAnalysis, 3, "West", "VP West");
		add_objects_and_links(linkAnalysis, 3, "South", "VP South");
		add_objects_and_links(linkAnalysis, 3, "North", "VP North");

		/*  SCENARIO 
		
		could work by making the link line a curve
		- if line intersects with another line -> increase curvature 
		
			 digraph {
				a -> b
				a -> c
				b -> d
				c -> d
			}
				var dir_east_west = { id: "East_West", name: "East_West", type: "person" };
				linkAnalysis.addObject(dir_east_west);
				linkAnalysis.addLink("VP East", "East_West");
				linkAnalysis.addLink("VP West", "East_West");
		*/


		linkAnalysis.setNodeClickHandler(function (node) {
			console.log("NODE CLICKED: " + node.id);
		});

		linkAnalysis.render();



		/*
				var main_person = {id: "p_123", name: "Eric Fox", type: "person", photo: "https://randomuser.me/api/portraits/men/22.jpg" };
				linkAnalysis.addObject(main_person);

				var vehicle = { name: "vehicle", type: "vehicle" };
				linkAnalysis.addObject(vehicle);
				linkAnalysis.addLink(vehicle, main_person);

				var fugitive_case = { name: "FCS0001089", type: "case" };
				linkAnalysis.addLink(fugitive_case, main_person);
		
				var node_arrest = { name: "AR-784723", type: "arrest" };
				linkAnalysis.addLink(node_arrest, main_person);
		
				var node_family = { name: "Family" };
				linkAnalysis.addLink(node_family, main_person);
		
				var node_Lisa = { "name": "FOX, Lisa", "relationship": "Wife", "age": "42", "degree_of_relationship": "0", "photo": "https://randomuser.me/api/portraits/women/33.jpg" };
				var node_Edward = { "name": "FOX, Edward", "relationship": "Son", "age": "18", "degree_of_relationship": "1", "photo": "https://randomuser.me/api/portraits/men/22.jpg" };
				var node_Cindy = { "name": "FOX, Cindy", "relationship": "Daughter", "age": "16", "degree_of_relationship": "1", "photo": "https://randomuser.me/api/portraits/women/33.jpg" };
				//var nodes_family = [node_Lisa, node_Edward, node_Cindy];
				// {"name":"PARK, Carlos","relationship":"Cousin","age":"38","degree_of_relationship":"3","photo":"https://dojopsdemo.service-now.com/c09393281bf01090f76f20252a4bcb1a.iix"}]
				linkAnalysis.addLink(node_Lisa, node_family);
				linkAnalysis.addLink(node_Edward, node_family);
				linkAnalysis.addLink(node_Cindy, node_family);
		
		
				var node_known_addresses = { name: "Known Addresses", "type": "location" };
				linkAnalysis.addLink(node_known_addresses, main_person);
				var node_place_A = { name: "808 W. Spokane Blvd., Spokane WA", "type": "address" };
				var node_place_B = { name: "188 Hunters Dr, Los Angeles CA", "type": "address" };
				var node_place_C = { name: "3256 East Market St, Los Angeles CA", "type": "address" };
				linkAnalysis.addLink(node_place_A, node_known_addresses);
				linkAnalysis.addLink(node_place_B, node_known_addresses);
				linkAnalysis.addLink(node_place_C, node_known_addresses);
		*/

		linkAnalysis.setIconByNodeType(IconByNodeType);







		//@TODO  LOAD
		//loadAllImages(ICON_LIST, start);
		//
	}


	function add_objects_and_links(linkAnalysis, object_count, prefix, target) {
		for (var index = 0; index < object_count; index++) {
			var object_id = prefix + " " + index;
			var object = { id: object_id, name: object_id, type: "person" };
			linkAnalysis.addObject(object);
			linkAnalysis.addLink(target, object_id);
		}
	}
</script>

</html>