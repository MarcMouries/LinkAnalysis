<html>
  <head>
    <script src="../src/Graph.js"></script>
    <script src="../src/layout/TreeLayout.js"></script>

    <link rel="stylesheet" href="./style.css" />

    <style>
      :root {
        --tree-bg-color: rgb(228, 241, 235);

        --node-bg-color: rgb(204, 251, 165);
        --node-bg-color-hover: rgb(31, 161, 90);
        --node-border-color: rgb(38, 196, 109);
        --node-font-color: #464646;

        --emp-count-bg-color: rgb(38, 196, 109);
        --emp-count-bg-color-hover: rgb(16, 94, 51);
        --emp-count-border-color: rgb(38, 196, 109);

        --breadcrumb-bg: linear-gradient(to right, rgb(38, 196, 109) 10%, rgb(204, 251, 165));
      }

      .canvas-container {
        max-width: 100%;
        overflow: scroll;
        border: 2px solid red;
        position: relative; /* allows the position: absolute; property of the child element (in this case, the .node/card-div)
         to be positioned relative to the .canvas-container element. */

      }

      /* width and height are calculated by the tree layout */
      #tree {
        border: 2px dotted yellowgreen;
      }

      .card_template_container {
        display: none;
      }

      .card {
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--node-border-color);
        border-radius: 5px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);

        width: 160px;
        height: 60px;
        background: var(--node-bg-color);
        color: (--node-font-color);
        font-size: 1.2em;
        font-family: sans-serif;
        cursor: pointer;
      }

      .card_TEST {
        display: inline-block;
        position: sticky;
        background: var(--node-bg-color);
        padding: 0.3em;
        word-spacing: normal;
        border-radius: 0;
        border: 1px solid var(--node-border-color);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        text-shadow: none;
        color: (--node-font-color);
        box-sizing: border-box;
        text-align: center;
        font-size: 1.2em;
        font-family: sans-serif;
        z-index: 100;
        cursor: pointer;
      }

      .card:hover {
        background: var(--node-bg-color-hover);
        transform: scale(1.2);
        z-index: 999;
        transition: 0.1s all ease;
        color: #fff;
      }

      .card .content {
        padding: 10px;
      }

      .card .title {
        background-color: rgba(96, 139, 168, 0.2);
        padding: 10px;
      }

      .card .user_photo img {
        width: 50px;
        border-radius: 50%;
      }
    </style>
  </head>

  <body>
    <h1>Test Org Chart</h1>
    <ul class="breadcrumb">
      <li><a href="../index.html">Home</a></li>
      <li>Test Graph</li>
    </ul>

    <div id="tree_dimension"></div>
    <div id="canvas_dimension"></div>

    <!--
	Create a template for the nodes and set the style visibility = "hidden" so that its dimensions can be calculated
 	-->
    <div id="card_template_container" class="card_template_container">
      <div id="card" class="card">
        <div>{id}</div>
      </div>
    </div>
    <div id="chart" class="canvas-container">
      <canvas id="tree"></canvas>
    </div>

    <!-- node_template -->
    <script>
      function getDivDimensions(div) {
        var cs = window.getComputedStyle(div);
        var div_width = cs.getPropertyValue("width");
        if (div_width) div_width = parseInt(div_width.replace("px", ""));
        var div_height = cs.getPropertyValue("height");
        if (div_height) div_height = parseInt(div_height.replace("px", ""));
        return { width: div_width, height: div_height };
      }

      var card_template_container = document.getElementById("card_template_container");
      var card_div = card_template_container.children[0];
      var node_div_dim = getDivDimensions(card_div);
      console.log("node_div_dim");
      console.log(node_div_dim);
      console.log("node_div dimensions: '" + node_div_dim.width + "' x '" + node_div_dim.height);

      function drawLine(ctx, x1, y1, x2, y2, stroke = "black", width = 2) {
        ctx.save();

        if (stroke) {
          ctx.strokeStyle = stroke;
        }
        if (width) {
          ctx.lineWidth = width;
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }
      console.log("==========================");
      //	var nodeZ = new Node("Z", {});
      //	nodeZ.attr("width", 666);
      console.log("==========================");

      var graph_walker = new Graph();
      // Root Node
      graph_walker.addObject({ id: "O", parentId: null, type: "standard" });

      // 1st Level
      graph_walker.addObject({ id: "E", parentId: "O", type: "standard" });
      graph_walker.addObject({ id: "F", parentId: "O", type: "standard" });
      graph_walker.addObject({ id: "N", parentId: "O", type: "standard" });

      // 2nd Level
      graph_walker.addObject({ id: "A", parentId: "E", type: "NEW" });
      graph_walker.addObject({ id: "D", parentId: "E", type: "standard" });

      graph_walker.addObject({ id: "G", parentId: "N", type: "standard" });
      graph_walker.addObject({ id: "M", parentId: "N", type: "standard" });

      // // 3rd Level
      graph_walker.addObject({ id: "B", parentId: "D", type: "standard" });
     graph_walker.addObject({ id: "C", parentId: "D", type: "standard" });
      // //
       graph_walker.addObject({ id: "H", parentId: "M", type: "NEW" });
       graph_walker.addObject({ id: "I", parentId: "M", type: "standard" });
       graph_walker.addObject({ id: "J", parentId: "M", type: "standard" });
       graph_walker.addObject({ id: "K", parentId: "M", type: "standard" });
       graph_walker.addObject({ id: "L", parentId: "M", type: "standard" });

      console.log("==========================");
      console.log("graph_walker", graph_walker);
      console.log("==========================");

      // New Nodes
      //	graph_walker.addObject({ id: "X", parentId: "N", type: "NEW" });
      //	graph_walker.addObject({ id: "Y", parentId: "N", type: "NEW" });

      /*
				console.log("==========================");
				console.log("=Test getLeftmost");
				console.log("==========================");

				var node = graph_walker.getNode("M");
				var Leftmost =  treeLayout.getLeftmost_ONE(node, 0, 2);
				console.log("==> Test getLeftmost " + node.id + " = " + Leftmost);
		*/

      var treeLayout = new TreeLayout(graph_walker, {
        nodeWidth: node_div_dim.width,
        nodeHeight: node_div_dim.height,
      });
      treeLayout.Calculate_Positions(graph_walker, { x: 100, y: 100 });
      var treeDimension = treeLayout.getTreeDimension();

      var canvas = document.getElementById("tree");
      var context = canvas.getContext("2d");
      let rect = canvas.getBoundingClientRect();
      console.log("CANVAS RECT");
      console.log(rect);
      console.log("Canvas Offset");
      //	var canvasoffsetTop = 0;
      //	var canvasoffsetLeft = 0;
      console.log(" -  offsetLeft : " + canvas.offsetLeft);
      console.log(" -  offsetTop : " + canvas.offsetTop);

      console.log(" -  treeDimension : ", treeDimension);

      // increase the actual size of our canvas
      canvas.width = treeDimension.width * devicePixelRatio;
      canvas.height = treeDimension.height * devicePixelRatio;

      //      canvas.width = rect.width * devicePixelRatio;
      //      canvas.height = rect.height * devicePixelRatio;

      context.scale(devicePixelRatio, devicePixelRatio);
      //      canvas.style.width = rect.width + "px";
      //      canvas.style.height = rect.height + "px";

      canvas.style.width = treeDimension.width + "px";
      canvas.style.height = treeDimension.height + "px";

      context.strokeStyle = "rgb(41, 62, 64)";

      var el_tree_dimension = document.getElementById("tree_dimension");
      el_tree_dimension.innerHTML = "Tree Dimension: " + treeDimension.width + " x " + treeDimension.height;

      var el_canvas_dimension = document.getElementById("canvas_dimension");
      el_canvas_dimension.innerHTML = "Canvas Dimension: " + canvas.style.width + " x " + canvas.style.height;

      var chart_container = document.getElementById("chart");

      /* Populate template with data by replacing strings between braces with properties in the data object
       * ex: "{first_name}" is replaced by data.first_name
       */
      function populate(template, data) {
        var content = template.replace(/\{(\w+)\}/g, function (_, k) {
          return data[k];
        });
        return content;
      }

      var connector_style = "ELBOW";
      //var connector_style = "STRAIGHT";

      var x1, y1, x2, y2, x3, y3, x4, y4;
      for (let index = 0; index < graph_walker.nodeList.length; index++) {
        const node = graph_walker.nodeList[index];

        if (node.data.type && node.data.type == "NEW") {
          context.strokeStyle = "rgb(128, 182, 161)";
          context.strokeSize = 2;
        } else {
          context.strokeStyle = "#0181a0";
        }
        //context.fillRect(node.x, node.y, node.width, node.height);
        context.strokeRect(node.x, node.y, node.width, node.height);

        context.font = "bold 20px Calibri";
        context.save();
        //context.fillStyle = 'rgb(255, 250, 255)';

        context.textBaseline = "middle";
        context.textAlign = "center";
        var textWidth = 0;
        //var textWidth = context.measureText(node.id ).width;
        context.fillStyle = "#0181a0";
        context.fillText(node.id, node.x + node.width / 2 - textWidth / 2, node.y + node.height / 2);

        // Create Node Content
        //console.log("node.type");			console.log(node);
        if (node.data.type == "NEW") {
          var node_div = card_div.cloneNode(true);
          node_div.innerHTML = populate(node_div.innerHTML, node);
          node_div.style.top = node.y + canvas.offsetTop + "px";
          node_div.style.left = node.x + canvas.offsetLeft + "px";
          node_div.style.position = "absolute";
          node_div.id = "node_" + node.id;
          chart_container.appendChild(node_div);
        }
        // Middle Of Node
        x1 = node.x + node.width / 2;
        y1 = node.y + node.height;
        var middleOfNode = [x1, y1];

        context.fillStyle = "black";
        context.font = "10px Calibri";
        context.fillText(`a (${x1},${y1})`, x1 + 5 + index * 10, y1 + 5);

        var line_color = "black";
        var line_width = 1.8;

        var childrenCount = node.children.length;

        // Straight line from parent to child just below it
        if (connector_style == "ELBOW" && childrenCount > 0) {
          var yy1 = y1 + treeLayout.levelSeparation / 2 - node.height / 2;
          console.log("y1  = " + y1);
          console.log("yy1 = " + yy1);
          console.log("levelSeparation = " + treeLayout.levelSeparation);
          drawLine(context, x1, y1, x1, yy1, "red", line_width);
        }
      
        if (!node.isLeaf()) {
            console.log ("Node is not a leaf : " + node.id)
            let leftMostChild = node.getLeftMostChild();
            let rightMostChild = node.getRightMostChild();
            console.log ("leftMostChild : " + leftMostChild)
            console.log ("rightMostChild : " + rightMostChild)

            
        } 

        /*
        for (var i = 0; i < childrenCount; i++) {
          var childNode = node.children[i];

          // STRAIGHT Connectors
          //
          if (connector_style == "STRAIGHT") {
            x2 = childNode.x + node.width / 2;
            y2 = childNode.y;
            drawLine(context, x1, y1, x2, y2, "green", 0.5);
          }
          // ELBOW ----------------------------
          if (connector_style == "ELBOW") {
            //line_color = 'black';

            x2 = x1;
            y2 = (childNode.y + node.y + node.height) / 2;
            line_color = "cyan";
           // context.fillText(`b (${x2},${y2})`, x2 + 5, y2 + 5);
            console.log("b = " + x2 + ", " + y2);
         // drawLine(context, x1, y1, x2, y2, line_color, line_width);

            // line connecting the children to the center line connecting to the parent
            // from the center of the parent to the center of this child node


            // instead draw a line across top of children


          // var leftMostChildPoint = new org_models_1.Point(_this.NODE_MARGIN_X + (node.getLeftMostChild().x * (_this.NODE_WIDTH + _this.NODE_MARGIN_X)) + (_this.NODE_WIDTH / 2), nodeBottomMiddlePoint.y + (_this.NODE_MARGIN_Y / 2));
          // var rightMostChildPoint = new org_models_1.Point(_this.NODE_MARGIN_X + (node.getRightMostChild().x * (_this.NODE_WIDTH + _this.NODE_MARGIN_X)) + (_this.NODE_WIDTH / 2), nodeBottomMiddlePoint.y + (_this.NODE_MARGIN_Y / 2));
          // var lineAcrossTopOfChildren = org_helper_1.createSvgLine(leftMostChildPoint.x, leftMostChildPoint.y, rightMostChildPoint.x, rightMostChildPoint.y, 'edge');
 

            x3 = childNode.x + childNode.width / 2;
            y3 = y2;
            if (i == 0 ) {
              line_color = "Tomato";
            }
            else if (i == 1 ) {
              line_color = "GreenYellow";
            }
            else if (i == 2 ) {
              line_color = "DodgerBlue";
            }
            else if (i == 3 ) {
              line_color = "Turquoise";
            }
            else if (i == 4 ) {
              line_color = "SlateBlue";
            }
            context.fillText("c" + i + childNode.id, x3 + 5 , y3 + 5 + i * 10);
            drawLine(context, x2, y2 + (i*10), x3 , y3 + (i*10), line_color, line_width);

            x4 = x3;
            y4 = childNode.y;
            //context.fillText(`d (${x4},${y4})`, x4 + 5, y4 - 5);
            line_color = "blue";
            drawLine(context, x3, y3, x4, y4, line_color, line_width);
          }
        }
      */
      }
      //console.log(graph_walker.nodeList);
/*
      const canvasContainer = document.querySelector('.canvas-container');
const floatingDiv = document.querySelector('.card');

canvasContainer.addEventListener('scroll', () => {
  floatingDiv.style.top = `${canvasContainer.scrollTop}px`;
  floatingDiv.style.left = `${canvasContainer.scrollLeft}px`;
});
*/
    </script>
  </body>
</html>
